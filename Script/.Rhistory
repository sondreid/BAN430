rename(diff_unemployed = ".mean_diff_unemployed")  %>%
group_by(.model)  %>%
mutate(diff_unemployed = cumsum(diff_unemployed) +  multivariate_data$unemployed %>% tail(1)) ## Add level
# AICc and BIC optimized forecast, VAR(5) and VAR(1)
forecast_level  %>%
autoplot() +
autolayer(unemployment_test_ts %>% filter(year(date) > 2007)) +
theme_bw() +
theme(legend.position = "bottom") +
labs(y = "Unemployment level",
x = "Month",
title = "Forecasting with VAR methods") +
guides(colour = guide_legend(title = "Method:")) +
scale_colour_manual(values=c("#56B4E9", "orange"))
forecast_level  %>%
autoplot() +
autolayer(unemployment_test_ts %>% filter(year(date) > 2007)) +
theme_bw() +
theme(legend.position = "bottom") +
labs(y = "Unemployment level",
x = "Month",
title = "Forecasting with VAR methods") +
guides(colour = guide_legend(title = "Method:")) +
scale_colour_manual(values=c("#56B4E9", "orange"))
"Cointegrated stochastic trends --> VECM"
VARselect(multivariate_data[,2:4], lag.max = 12, type="const")[["selection"]] # Confirming AR term
# Johansen test
### Identify cointegration between variables
ca_jo <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "trace",
K = 10, season = 12  ) ## k = 5 AR terms
summary(ca_jo)
var_vec <- vec2var(ca_jo, r =1)
serial.test(var_vec, lags.pt=10, type="PT.asymptotic")
fc_vecm <- predict(var_vec, n.ahead = 24)
fc_var_vec <- data.frame("date"= unemployment_test$date,
"unemployed" = (predict(var_vec, n.ahead = 24)[[1]]$unemployed)[,1:3])
colnames(fc_var_vec) <- c("date", "unemployed", "lower", "upper")
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("#eb3434", "black", "#56B4E9", "#56B4E9")) +
theme_bw()
#Performance metrics
vecm_resids <- (unemployment_test$unemployed - fc_var_vec$unemployed)
data.frame(Model = "Multivariate VAR model AICc optimized (AR5)",
Type = "Test",
RMSE = RMSE(var_aicc_resid),
MAE =  MAE(var_aicc_resid),
MAPE = fabletools::MAPE(.resid = var_aicc_resid, .actual = c(unemployment_test$unemployed)),
MASE =  MASE(.resid = var_aicc_resid, .train = c(unemployment_train_ts$unemployed), .period = 12),
RMSSE = RMSSE(.resid = var_aicc_resid, .train = c(unemployment_train_ts$unemployed), .period = 12)) %>%
bind_rows( data.frame(Model = "Multivariate VECM model AR(10)",
Type = "Test",
RMSE = RMSE(vecm_resids),
MAE =  MAE(vecm_resids),
MAPE = fabletools:: MAPE(.resid = vecm_resids, .actual = c(unemployment_test$unemployed)),
MASE = MASE(.resid = vecm_resids, .train = c(unemployment_train_ts$unemployed), .period = 12),
RMSSE = RMSSE(.resid = vecm_resids, .train = c(unemployment_train_ts$unemployed), .period = 12)),
data.frame(Model = "Multivariate VAR model BIC optimized",
Type = "Test",
RMSE = RMSE(var_bic_resid),
MAE =  MAE(var_bic_resid),
MAPE = fabletools:: MAPE(.resid = var_bic_resid, .actual = c(unemployment_test$unemployed)),
MASE = MASE(.resid = var_bic_resid, .train = c(unemployment_train_ts$unemployed), .period = 12),
RMSSE = RMSSE(.resid = var_bic_resid, .train = c(unemployment_train_ts$unemployed), .period = 12))) %>%
arrange(MASE) %>%
kbl(caption = "Multivariate VAR models", digits = 2) %>%
kable_classic(full_width = F, html_font = "Times new roman")
VARselect(multivariate_data[,2:4], lag.max = 12, type="const")[["selection"]] # Confirming AR term
VARselect(multivariate_data[,2:4], lag.max = 12, type="const")[["selection"]] # Confirming AR term
# Johansen test
### Identify cointegration between variables
ca_jo <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "trace",
K = 10, season = 12  ) ## k = 5 AR terms
VARselect(multivariate_data[,2:4], lag.max = 12, type="const")[["selection"]] # Confirming AR term
# Johansen test
### Identify cointegration between variables
ca_jo <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "trace",
K = 4, season = 12  ) ## k = 5 AR terms
summary(ca_jo)
var_vec <- vec2var(ca_jo, r =1)
serial.test(var_vec, lags.pt=10, type="PT.asymptotic")
fc_vecm <- predict(var_vec, n.ahead = 24)
fc_var_vec <- data.frame("date"= unemployment_test$date,
"unemployed" = (predict(var_vec, n.ahead = 24)[[1]]$unemployed)[,1:3])
colnames(fc_var_vec) <- c("date", "unemployed", "lower", "upper")
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("#eb3434", "black", "#56B4E9", "#56B4E9")) +
theme_bw()
#Performance metrics
VARselect(multivariate_data[,2:4], lag.max = 12, type="const")[["selection"]] # Confirming AR term
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("#eb3434", "black", "#56B4E9", "#56B4E9")) +
theme_bw()
VARselect(multivariate_data[,2:4], lag.max = 12, type="const")[["selection"]] # Confirming AR term
# Johansen test
### Identify cointegration between variables
ca_jo <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "trace",
K = 10, season = 12  ) ## k = 5 AR terms
summary(ca_jo)
var_vec <- vec2var(ca_jo, r =1)
serial.test(var_vec, lags.pt=10, type="PT.asymptotic")
fc_vecm <- predict(var_vec, n.ahead = 24)
fc_var_vec <- data.frame("date"= unemployment_test$date,
"unemployed" = (predict(var_vec, n.ahead = 24)[[1]]$unemployed)[,1:3])
colnames(fc_var_vec) <- c("date", "unemployed", "lower", "upper")
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("#eb3434", "black", "#56B4E9", "#56B4E9")) +
theme_bw()
forecast_level  %>%
autoplot() +
autolayer(unemployment_test_ts %>% filter(year(date) > 2007)) +
theme_bw() +
theme(legend.position = "bottom") +
labs(y = "Unemployment level",
x = "Month",
title = "Forecasting with VAR methods") +
guides(colour = guide_legend(title = "Method:")) +
scale_colour_manual(values=c("#56B4E9", "orange"))
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
#geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
#geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("black", "orange")) +
theme_bw()
e
var_vec <- vec2var(ca_jo, r =1)
serial.test(var_vec, lags.pt=10, type="PT.asymptotic")
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts %>% filter(year(date) > 2007)) +
#geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
#geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("black", "orange")) +
theme_bw()
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts %>% filter(year(date) > 2007)) +
#geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
#geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("black", "orange")) +
theme_bw(legend.position = "bottom")
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts %>% filter(year(date) > 2007)) +
#geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
#geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("black", "orange")) +
theme_bw(legend.position = "bottom")
fc_var_vec  %>%
ggplot() +
geom_line(aes(x = date, y = unemployed, color = "VECM model")) +
geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts %>% filter(year(date) > 2007)) +
#geom_line(aes(x = date, y = lower, color = "Lower prediction interval", alpha = 0.5)) +
#geom_line(aes(x = date, y = upper, color = "Upper prediction interval", alpha = 0.5)) +
scale_colour_manual(values=c("black", "orange")) +
theme_bw() +
theme(legend.position = "bottom")
serial_port_test <- (serial.test(fit_multivariate_var, lags.pt=24, type="PT.asymptotic"))$serial
unitroot_kpss(diff_ex)
multivariate_data  %>%
features(cpi, unitroot_kpss)
multivariate_data <- unemployment_train_ts %>%
dplyr::select(date, unemployed)  %>%
left_join(cpi_train, by = "date")  %>%
left_join(export_train, by = "date")
# CPI: Autocorrelation plots
ggtsdisplay(multivariate_data$cpi,
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "CPI")
# Export: Autocorrelation plots
ggtsdisplay(multivariate_data$export,
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "Exports")
# CPI: KPSS test. Outcome: 1.26% p-value, needs differencing
multivariate_data  %>%
features(cpi, unitroot_kpss)
source("data.r")
###############################################################################
################## Stationarity test: Exports and CPI #########################
###############################################################################
# Joining unemployment data with consumer price index (cpi) and export
multivariate_data <- unemployment_train_ts %>%
dplyr::select(date, unemployed)  %>%
left_join(cpi_train, by = "date")  %>%
left_join(export_train, by = "date")
# CPI: Autocorrelation plots
ggtsdisplay(multivariate_data$cpi,
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "CPI")
# Export: Autocorrelation plots
ggtsdisplay(multivariate_data$export,
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "Exports")
# CPI: KPSS test. Outcome: 1.26% p-value, needs differencing
multivariate_data  %>%
features(cpi, unitroot_kpss)
multivariate_data  %>%
features(difference(cpi), unitroot_kpss)
# CPI: KPSS test. Outcome: 10% p-value, no need for further differencing
multivariate_data  %>%
features(difference(export), unitroot_kpss)
# CPI: KPSS test. Outcome: 10% p-value, no need for further differencing
multivariate_data  %>%
features(export, unitroot_kpss)
var13 <- vars:: VAR(ts(multivariate_data_stationary[,2:4]), p = 13, type="const")
fit_multivariate_var <- multivariate_data_stationary %>%
model(VAR_aicc = fable::VAR(vars(diff_unemployed , diff_diff_cpi, diff_diff_export), ic = "aicc"),
VAR_bic = fable::VAR(vars(diff_unemployed , diff_diff_cpi, diff_diff_export), ic = "bic"))
fit_multivariate_var
var5 <- vars:: VAR(ts(multivariate_data_stationary[,2:4]), p = 5, type="const")
serial_port_test <- (serial.test(var5, lags.pt=24, type="PT.asymptotic"))$serial
serial_port_test
serial_port_test <- (serial.test(var5, lags.pt=4, type="PT.asymptotic"))$serial
serial_port_test <- (serial.test(var5, lags.pt=4, type="PT.asymptotic"))$serial
serial_port_test
serial_port_test <- (serial.test(var5, lags.pt=12, type="PT.asymptotic"))$serial
serial_port_test
serial_port_test <- (serial.test(var5, lags.pt=24, type="PT.asymptotic"))$serial
plot(var5)
Box.test(diff_ex)
acf(diff_ex)
acf(diff_ex)
acf(ts(diff_ex)
)
ACF(diff_ex)
Box.test(resid(diff_ex)
Box.test(resid(diff_ex))
ggtsdisplay(difference(multivariate_data_stationary$cpi),
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "Differenced CPI")
multivariate_data_stationary
multivariate_data_stationary <- multivariate_data  %>%
mutate(diff_unemployed = difference(difference(unemployed)),
diff_diff_export                   = difference(difference(export)),
diff_diff_cpi                      = difference(difference(cpi)))  %>%
dplyr::select(date, diff_unemployed, diff_diff_export, diff_diff_cpi)  %>%
as_tsibble()
multivariate_data_stationary   %<>%
filter(date > yearmonth("2000-02-01"))
ggtsdisplay(difference(multivariate_data_stationary$cpi),
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "Differenced CPI")
ggtsdisplay(multivariate_data_stationary$cpi,
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "Differenced CPI")
ggtsdisplay(multivariate_data_stationary$diff_diff_cpi,
plot.type = "partial",
lag.max = 24,
theme = theme_bw(),
main = "Differenced CPI")
serial.test(var5, lags.pt=24, type="PT.asymptotic")
serial.test(var5, lags.pt=24, type="PT.asymptotic", df =4)
help(serial.test)
serial.test(var5, lags.pt=24, type="PT.asymptotic", df =4)
serial.test(var5, lags.pt=24, type="PT.asymptotic")
VARselect(multivariate_data_stationary[,2:4], lag.max =24, type="const")[["selection"]] # Confirming AR term
VARselect(multivariate_data[,2:4], lag.max = 12, type="const")[["selection"]] # Confirming AR term
fit_multivariate_var <- multivariate_data_stationary %>%
model(VAR_aicc = fable::VAR(vars(diff_unemployed , diff_diff_cpi, diff_diff_export), ic = "aicc"),
VAR_bic = fable::VAR(vars(diff_unemployed , diff_diff_cpi, diff_diff_export), ic = "bic"))
fit_multivariate_var   augment() %>%
ACF(.innov) %>%
autoplot()
fit_multivariate_var  %>%  augment() %>%
ACF(.innov) %>%
autoplot()
fit_deterministic <- unemployment_train_ts %>%
dplyr::select(date, unemployed) %>%
model(Deterministic = ARIMA(unemployed ~ 1 + trend() + pdq(d=0)))
fc_deterministic <- fit_deterministic %>%
forecast(h = 24)
Residuals <- augment(fit_deterministic)$.innov
fit_deterministic %>%
augment() %>%
features(.innov, unitroot_kpss)
ggtsdisplay(Residuals,
plot.type = "histogram",
lag.max = 24,
theme = theme_bw(),
main = paste("Residuals of ARIMA ", fit_deterministic$Deterministic))
fc_deterministic %>%
autoplot(unemployment_test_ts, level = 95) +
labs(title = "Deterministic forecast",
x = "Month",
y = "Unemployment level") +
theme_bw() +
theme(legend.position = "bottom") +
guides(level = guide_legend(title = "Prediction level"))
setwd("G:/Dokumenter/Google drive folder/NHH/Master/BAN430/Repository/Script")
source("data.r")
load(file = "../Data/optimal_models.Rdata")
set.seed(12345)
unemployment_ts <- unemployment %>% as_tsibble(index = date)
arima_fit <- unemployment_ts  %>%
model(arima_optimal = ARIMA(unemployed, stepwise = FALSE, approximation = FALSE))
arima_fit  %>% forecast(h=24)  %>% autoplot() + autolayer(unemployment_ts)
gg_tsresiduals(arima_fit)
n <- 240
fit <- arima_fit
generate_y <- function(fit, n, d = 1) {
#'
#' Returns vector of residuals + random component
sigma <- sd(residuals(fit)$.resid)
resids <- residuals(fit)$.resid
mean_resid <- mean(residuals(fit)$.resid)
ar_terms <- arima_fit  %>% coefficients %>% dplyr::select(term, estimate)  %>%  filter(str_detect(term, "ar")) # AR terms and their coefficients
ma_terms <- arima_fit  %>% coefficients %>% dplyr::select(term, estimate)  %>%  filter(str_detect(term, "ma")) # AR terms and their coefficients
p <- ar_terms %>%  nrow() # AR term number
m <- ma_terms  %>%  nrow()
y <- rnorm(n, mean = mean(unemployment_ts$unemployed), sd = (sigma/sqrt(n)))
for (i in (p+2):n) {
if (d > 0) {
for (f in 1:d ) {
y <- diff(y)
}
}
#y[i] <- y[i] +  y[i-1]
if (p > 0 ) {
for(j in 1:p) {
y[i] <- y[i] + (y[i-j] - y[i-j-1]) * ar_terms$estimate[j]
}
}
if( m > 0 && i > 12*m) {
for(k in 1:m) {
y[i] <- y[i] + (resids[i-12*k] * ma_terms$estimate[k])
}
}
}
return (y)
}
generate_y(arima_fit, 216, 1)
plot(generate_y(arima_fit, 216), type = "l")
y_avg <- rep(0,n)
simulate <- function(R = 10000, train_length = 216, h = 24) {
res <- matrix(0,2,1)
colnames(res) <- c("MSE")
rownames(res)<- c("VAR multivariate", "ARIMA yt")
for(i in 1:R){
y <- generate_y(arima_fit, train_length+h)
y_e <- y[1:train_length]
y_t <- y[(train_length+1):(train_length+h)]
y_avg <- y_avg + y/R
x <- c()
x[1] <- 0
for (j in 2:(train_length+h)) {
x[j] <- 0.5*y[j-1] + 0.5*x[j-1]
}
x_e <- x[1:train_length]
x_t <- x[(train_length+1):(train_length+h)]
data_x_y = data.frame(date = unemployment_train_ts$date, x_e = x_e, y_e = y_e)  %>%  as_tsibble(index = date)
ar_term <- VARselect(data_x_y[,2:3], lag.max =10, type="const")[["selection"]] # Confirming AR term
var_multi  <- vars:: VAR(data_x_y[,2:3], p  = ar_term[[2]])
#var_multi <- data_x_y %>% model(var_multi = fable::VAR(vars(y_e, x_e) ~ AR(p = 0:5)))
# print(paste("y_t", y_t))
# print(paste("y_e", y_e))
# print(y_t- predict(var_multi, n.ahead = 24)$fcst$y_e)
if (any(is.na(predict(var_multi, n.ahead = 24)$fcst$y_e))) {
next
}
else {
res[1] <- res[1] + (y_t -  predict(var_multi, n.ahead = 24)$fcst$y_e)[,1]^2/R
arima_uni <- data_x_y  %>% model(Arima = ARIMA(y_e, stepwise = TRUE, approximation = TRUE))
res[2] <- res[2] + (y_t -  predict(arima_uni)$.mean)^2/R
}
}
return(res)
}
sim_res <- simulate()
generate_y <- function(fit, n, d = 1) {
#'
#' Returns vector of residuals + random component
sigma <- sd(residuals(fit)$.resid)
resids <- residuals(fit)$.resid
mean_resid <- mean(residuals(fit)$.resid)
ar_terms <- arima_fit  %>% coefficients %>% dplyr::select(term, estimate)  %>%  filter(str_detect(term, "ar")) # AR terms and their coefficients
ma_terms <- arima_fit  %>% coefficients %>% dplyr::select(term, estimate)  %>%  filter(str_detect(term, "ma")) # AR terms and their coefficients
p <- ar_terms %>%  nrow() # AR term number
m <- ma_terms  %>%  nrow()
y <- rnorm(n, mean = mean(unemployment_ts$unemployed), sd = (sigma/sqrt(n)))
for (i in (p+2):n) {
'        if (d > 0) {
for (f in 1:d ) {
y <- diff(y)
}
}'
#y[i] <- y[i] +  y[i-1]
if (p > 0 ) {
for(j in 1:p) {
y[i] <- y[i] + (y[i-j] - y[i-j-1]) * ar_terms$estimate[j]
}
}
if( m > 0 && i > 12*m) {
for(k in 1:m) {
y[i] <- y[i] + (resids[i-12*k] * ma_terms$estimate[k])
}
}
}
return (y)
}
generate_y(arima_fit, 216, 1)
plot(generate_y(arima_fit, 216), type = "l")
y_avg <- rep(0,n)
simulate <- function(R = 10000, train_length = 216, h = 24) {
res <- matrix(0,2,1)
colnames(res) <- c("MSE")
rownames(res)<- c("VAR multivariate", "ARIMA yt")
for(i in 1:R){
y <- generate_y(arima_fit, train_length+h)
y_e <- y[1:train_length]
y_t <- y[(train_length+1):(train_length+h)]
y_avg <- y_avg + y/R
x <- c()
x[1] <- 0
for (j in 2:(train_length+h)) {
x[j] <- 0.5*y[j-1] + 0.5*x[j-1]
}
x_e <- x[1:train_length]
x_t <- x[(train_length+1):(train_length+h)]
data_x_y = data.frame(date = unemployment_train_ts$date, x_e = x_e, y_e = y_e)  %>%  as_tsibble(index = date)
ar_term <- VARselect(data_x_y[,2:3], lag.max =10, type="const")[["selection"]] # Confirming AR term
var_multi  <- vars:: VAR(data_x_y[,2:3], p  = ar_term[[2]])
#var_multi <- data_x_y %>% model(var_multi = fable::VAR(vars(y_e, x_e) ~ AR(p = 0:5)))
# print(paste("y_t", y_t))
# print(paste("y_e", y_e))
# print(y_t- predict(var_multi, n.ahead = 24)$fcst$y_e)
if (any(is.na(predict(var_multi, n.ahead = 24)$fcst$y_e))) {
next
}
else {
res[1] <- res[1] + (y_t -  predict(var_multi, n.ahead = 24)$fcst$y_e)[,1]^2/R
arima_uni <- data_x_y  %>% model(Arima = ARIMA(y_e, stepwise = TRUE, approximation = TRUE))
res[2] <- res[2] + (y_t -  predict(arima_uni)$.mean)^2/R
}
}
return(res)
}
sim_res <- simulate()
simulate <- function(R = 100, train_length = 216, h = 24) {
res <- matrix(0,2,1)
colnames(res) <- c("MSE")
rownames(res)<- c("VAR multivariate", "ARIMA yt")
for(i in 1:R){
y <- generate_y(arima_fit, train_length+h)
y_e <- y[1:train_length]
y_t <- y[(train_length+1):(train_length+h)]
y_avg <- y_avg + y/R
x <- c()
x[1] <- 0
for (j in 2:(train_length+h)) {
x[j] <- 0.5*y[j-1] + 0.5*x[j-1]
}
x_e <- x[1:train_length]
x_t <- x[(train_length+1):(train_length+h)]
data_x_y = data.frame(date = unemployment_train_ts$date, x_e = x_e, y_e = y_e)  %>%  as_tsibble(index = date)
ar_term <- VARselect(data_x_y[,2:3], lag.max =10, type="const")[["selection"]] # Confirming AR term
var_multi  <- vars:: VAR(data_x_y[,2:3], p  = ar_term[[2]])
#var_multi <- data_x_y %>% model(var_multi = fable::VAR(vars(y_e, x_e) ~ AR(p = 0:5)))
# print(paste("y_t", y_t))
# print(paste("y_e", y_e))
# print(y_t- predict(var_multi, n.ahead = 24)$fcst$y_e)
if (any(is.na(predict(var_multi, n.ahead = 24)$fcst$y_e))) {
next
}
else {
res[1] <- res[1] + (y_t -  predict(var_multi, n.ahead = 24)$fcst$y_e)[,1]^2/R
arima_uni <- data_x_y  %>% model(Arima = ARIMA(y_e, stepwise = TRUE, approximation = TRUE))
res[2] <- res[2] + (y_t -  predict(arima_uni)$.mean)^2/R
}
}
return(res)
}
sim_res <- simulate()
sim_res
sim_res
