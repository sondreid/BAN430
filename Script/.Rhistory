    labs(title = "Replication of the seasonal adjusted data",
         y     = "Seasonal Adjusted Unemployment level",
         x     = "Month") +
    guides(colour = guide_legend("Decomposition method:")) +
    theme_bw() +
    theme(legend.position = "bottom") +
    scale_colour_manual(values=c("black","green", "red", "orange"))
# Compare RMSE to find closest fit to original seasonal adjusted unemployment data of US
t(bind_rows(
    "Model" = c("ME", "RMSE", "MAE",  "MPE", "MAPE" ),
    X11 = c((ts(x11_dcmp$seasonaladj) %>% accuracy(ts(unemployment_train_ts$seasonal_unemployed)))[1:5]),
    X13 = c((ts(x13_dcmp$seasonaladj) %>% accuracy(ts(unemployment_train_ts$seasonal_unemployed)))[1:5]),
    STL = c((ts(stl_dcmp$season_adjust) %>% accuracy(ts(unemployment_train_ts$seasonal_unemployed)))[1:5])))  %>% 
    kbl(caption = "Evaluation metrics of decomposition methods", digits = 2) %>%
    kable_classic(full_width = F, html_font = "Times new roman")
# x11 decomposed plot
x11_dcmp %>% 
    dplyr::select(-seasonaladj) %>% 
    pivot_longer(cols = seasonal:unemployed,
                 names_to = "components",
                 values_to = "values") %>% 
    autoplot() +
    facet_grid(vars(components),
               scales = "free_y") +
    labs(title = "X11 decomposition of Unemployment US",
         subtitle = "Unemployed = Trend + Seasonal + Irregular",
         y = "Unemployment level",
         x = "Month") +
    guides(colour = FALSE) +
    theme_bw()
# x13 decomposed plot
x13_dcmp %>% 
    dplyr::select(-seasonaladj) %>% 
    pivot_longer(cols = seasonal:unemployed,
                 names_to = "components",
                 values_to = "values") %>% 
    autoplot() +
    facet_grid(vars(components),
               scales = "free_y") +
    labs(title = "X13 decomposition of Unemployment US",
         subtitle = "unemployed = trend + seasonal + irregular",
         y = "Unemployment level",
         x = "Month") +
    guides(colour = FALSE)
########################################################################################
######################## FORECASTING OF DECOMPOSITION ##################################
########################################################################################
# Choosing X11 because of best RMSE
# Forecast indivial compnents of the X11 decomposition
# Testset of the best decomposition method
x11_seas_test <- seas(ts(unemployment %>% dplyr::select(unemployed), 
                         start = c("2000"), 
                         frequency = 12), 
                      x11 = "")
# Decomposed in seasonal, trend and irregularities of testset
x11_dcmp_test <- data.frame(x11_seas_test) %>%
    left_join(dplyr::select(unemployment_test_ts, unemployed), by = "date") %>% 
    dplyr::select(-adjustfac, -final, -seasonaladj)  %>% 
    mutate(date = yearmonth(date)) %>% 
    as_tsibble(index = date)  %>% 
    pivot_longer(cols = seasonal:unemployed,
                 names_to = "components",
                 values_to = "values") 
# Train with mean, drift, naive, snaive, ets models 
x11_models <- x11_dcmp %>%
    pivot_longer(cols = seasonal:unemployed,
                 names_to = "components",
                 values_to = "values") %>% 
    model(Mean = MEAN(values),
          Drift = RW(values ~ drift()),
          Naive = NAIVE(values),
          SNaive = SNAIVE(values ~ lag("year"))) # HUKS ? SJEKKE ETS!!!!!!!!!!!!!!!!!!!!!!!!!
# x11 forecasting each of the decomposition part
fc_x11 <- x11_models %>% 
    forecast(h = 24)
# Forecasting each of the individual decomposed series 
x11_models  %>% 
    filter(components != "seasonaladj") %>% 
    forecast(h = 24)  %>%
    ggplot() +
    geom_line(aes(x = date, y = .mean, col = .model)) +
    geom_line(aes(x = date, y = values), data = x11_dcmp_test %>% filter(year(date) >= 2000 & year(date) <= 2019 )) +
    facet_grid(vars(components),
               scales = "free_y") +
    labs(title = "Forecast with X11 decomposition",
         subtitle = "Unemployed = Trend + Seasonal + Irregular",
         y = "Unemployment level",
         x = "Month") +
    guides(colour = guide_legend(title = "Model:")) +
    theme_bw()  +
    theme(legend.position = "bottom")
# HUSK ? FIKSE LEGENDS
# Forming forcaste of the test
fc_x11 %>% 
    filter(!components %in% c("seasonaladj", "unemployed")) %>% 
    group_by(.model) %>% 
    summarise("Unemployment level" = sum(.mean)) %>% 
    autoplot() +
    autolayer(unemployment_test_ts %>% filter(year(date) >= 2000)) +
    guides(colour = guide_legend(title = "Model:")) +
    labs(title = "Forcasting with X11 decomposition",
         subtitle = "Unemployed = Trend + Season + Irregular",
         x = "Month") +
    theme_bw() +
    theme(legend.position = "bottom")
##################################################################################
################################ ETS model #######################################
##################################################################################
# Fitting the trainingset with the best ETS model by minimizing AICc
fit_ets <- unemployment_train_ts %>%
    dplyr::select(date, unemployed) %>% 
    model(ETS_optimal = ETS(unemployed, ic = "aicc"),
          "ETS(A,A,A)"  = ETS(unemployed ~ error("A") + trend("A") + season("N"),  ic = "aicc")
    ) 
fit_ets_optimal <- unemployment_train_ts %>%
    dplyr::select(date, unemployed) %>% 
    model(ETS_optimal = ETS(unemployed)
    ) 
fc_ets_optimal <-  fit_ets_optimal %>% forecast(h = 24)
fit_ets # Error: Additive, Trend: Additive damped, Seasonal: Additive
tidy(fit_ets) %>% 
    dplyr::select(-.model) %>% 
    pivot_wider(names_from = term, values_from = estimate) %>% 
    kbl(caption = "Coefficients of ETS(A,Ad,A)", digits = 2) %>%
    kable_classic(full_width = F, html_font = "Times new roman")
# ETS decomposition plot
fit_ets %>% 
    components() %>%
    pivot_longer(cols = unemployed:remainder,
                 names_to  = "components",
                 values_to = "values") %>%
    autoplot()+
    facet_grid(vars(components),
               scales = "free_y") +
    labs(title = "ETS(A, AD, A)",
         y = "Component unemployment level",
         x = "Month") +
    theme_bw() 
### Forecast ETS with levels
fit_ets %>% 
    forecast(h = 24) %>% 
    autoplot(level = 95) +
    autolayer(unemployment_test_ts  %>% filter(year(date) >= 2007), unemployed) +
    labs(title = "Forecast with ETS",
         y = "Unemployment level",
         x = "Month") +
    theme_bw() +
    theme(legend.position = "bottom")
##################### Comparison with other methods ###################################
models_ets_comparisons_naiv_snaive <-  unemployment_train_ts %>%
    model(snaive = SNAIVE(unemployed),
          naiv   = NAIVE(unemployed)) %>% 
    forecast(h = 24) 
# Plot vs simple forcecast methods
fit_ets %>% 
    forecast(h = 24) %>% 
    ggplot() +
    geom_line(aes(x = date, y  = .mean, col = "ETS(A, AD, A)")) +
    geom_line(aes(x = date, y  = .mean, col = "Snaive"), data = models_ets_comparisons_naiv_snaive %>% filter(.model == "snaive")) + 
    geom_line(aes(x = date, y  = .mean, col = "Naive"), data = models_ets_comparisons_naiv_snaive %>% filter(.model == "naiv")) + 
    geom_line(aes(x = date, y  = unemployed, col = "Observed unemployment"), data = unemployment_test_ts %>% filter(year(date) > 2007, year(date) < 2019)) + 
    labs(title = "Forecast with ETS",
         y = "Unemployment level",
         x = "Month") +
    theme_bw() +
    guides(colour = guide_legend(title = "Legend")) +
    theme(legend.position = "bottom")
fit_ets_optimal %>% 
    forecast(h = 24) %>% 
    autoplot(unemployment_test_ts %>% filter(year(date) >= 2000), 
             level = 95) +
    labs(title = "Forecast of Unemployment level with",
         subtitle = fit_ets_optimal$ETS_optimal,
         y = "Unemployment level", 
         x = "Month") +
    theme_bw() +
    theme(legend.position = "bottom") +
    guides(level = guide_legend(title = "Prediction interval %: "))
fit_ets_optimal %>% 
    components() %>% 
    autoplot() +
    labs(x = "Month",
         y = "Unemployment level") +
    theme_bw()
models_ets_comparisons <-  unemployment_train_ts %>%
    model(snaive = SNAIVE(unemployed),
          naiv   = NAIVE(unemployed)) %>% forecast(h = 24) %>%
    bind_rows(fit_ets %>% 
                  forecast(h = 24)) %>% 
    accuracy(unemployment_test_ts) %>% 
    mutate(.model = c("ETS(A,A,A)", "ETS(A,Ad,A)", "Naive", "SNaive")) %>% 
    arrange(MASE) %>% 
    rename("Model" = .model) %>% 
    dplyr::select(-".type", -ACF1)
# Comparisons with simpler forecast methods
models_ets_comparisons %>% 
    kbl(caption = "ETS model compared with simple benchmark forecasting models", digits = 2) %>%
    kable_classic(full_width = F, html_font = "Times new roman")
# Checking for problems with non-stationarity, acf or normal-distribution ------
# The residuals does not seem to have sign of correlation, the histogram is a little bit skewed but seems to be normally distributed. We can use the prediction interval.  
Residuals <- residuals(fit_ets)$.resid
ggtsdisplay(residuals, 
            plot.type = "histogram", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Residuals of ETS(A,Ad,A) model")
fit_ets_optimal %>% 
    components()
Residuals <- augment(fit_ets_optimal)$.resid
ggtsdisplay(Residuals, 
            plot.type = "histogram", 
            lag.max = 24, 
            theme = theme_bw(),
            main = paste("Residuals of ", fit_ets_optimal$ETS_optimal, "model"))
fit_ets %>% 
    augment() %>% 
    features(.innov, ljung_box, lag = 34, dof = 4) # p-value of 3.61% under the 5%-significance level indicates that the autocorrelation comes from white-noise --> OK
# Accuracy of ETS by train and test
accuracy_ets <- bind_rows(
    fit_ets %>% accuracy(),
    fit_ets %>% forecast(h = 12) %>% accuracy(unemployment_test_ts)
) %>% 
    dplyr::select(-ME, -MPE, -ACF1) %>% 
    arrange(MASE)
accuracy_ets %>% 
    kbl(caption = "Accuracy of ETS(A,Ad,A)", digits = 2) %>%
    kable_classic(full_width = F, html_font = "Times new roman")
################################################################################
########################### ARIMA PREPARATION ##################################
################################################################################
# Plots of differenced unemployed, autocorrelation and partial autocorrelation
ggtsdisplay(unemployment_train_ts_stationarity$unemployed, 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Non-stationary Unemployment level in US")
unemployment_train_ts  %>% 
    features(unemployed, ljung_box, lag = 24) # Problems with autocorrelation
# Unitroot KPSS test on unemployed
unemployment_train_ts_stationarity %>% 
    features(unemployed, unitroot_kpss)
"Clearly non- stationary data with heavy trend in mean. Differencing first order makes mean stationary.
Variance not an issue, if so then log-transform"
unemployment_train_ts %>% mutate(diff_unemployed  = difference(unemployed)) %>% ACF(var = diff_unemployed, lag_max = 24) %>% autoplot()
" Significant lag at 12 and 24 months suggest seasonal autocorrelation. It is therefore necessary to perform a seasonal differencing operation."
unemployment_train_ts_stationarity <- unemployment_train_ts %>% 
    mutate(diff_season_unemployed = difference(unemployed, 12),
           diff_unemployed        = difference(unemployed),
           diff_diff_season_unemployed = difference(diff_season_unemployed))
unemployment_train_ts_stationarity %>%  ACF(var = diff_season_unemployed) %>% autoplot()
# number of diffs
unemployment_train_ts_stationarity %>% 
    features(diff_season_unemployed, unitroot_ndiffs)
unemployment_train_ts_stationarity %>% 
    features(diff_unemployed, unitroot_kpss)  # p-value of 1% is significant under 5%-significance level. KPSS(Kviatkowski-Phillips-Scmidt_Shin), indicating that there is need for differencing
unemployment_train_ts_stationarity %>% 
    features(diff_season_unemployed, unitroot_ndiffs)
unemployment_train_ts_stationarity %>% 
    gg_tsdisplay(diff_unemployed, plot_type = "partial")
"From the PACF we can see that there is "
unemployment_train_ts_stationarity %>% 
    features(diff_season_unemployed, unitroot_kpss) # p-value of 5.49%, might be need for differencing
unemployment_train_ts_stationarity %>% 
    features(diff_unemployed, unitroot_kpss) # p-value of 10%, no need for more differencing.
unemployment_train_ts_stationarity %>% 
    features(diff_diff_season_unemployed, unitroot_kpss)
unemployment_train_ts_stationarity %>% 
    gg_tsdisplay(diff_diff_season_unemployed, plot_type = "partial", lag_max = 24)
ggtsdisplay(unemployment_train_ts_stationarity$diff_diff_season_unemployed, 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Difference of seasonal differenced Unemployment level in US")
# Plotting unemployed and diff-unemployed
unemployment_train_ts_stationarity %>% 
    dplyr::select(-seasonal_unemployed) %>% 
    pivot_longer(cols = unemployed:diff_season_unemployed,
                 names_to = "components",
                 values_to = "values") %>% 
    autoplot() +
    facet_grid(vars(components))
# Autocorrelation of unemployed and diff-unemployed
unemployment_train_ts_stationarity %>% 
    dplyr::select(-seasonal_unemployed) %>% 
    pivot_longer(cols = unemployed:diff_diff_season_unemployed,
                 names_to = "components",
                 values_to = "values") %>% 
    ACF(lag_max = 24) %>% 
    autoplot() +
    facet_grid(vars(components))
unemployment_train_ts_stationarity %>% 
    dplyr::select(-seasonal_unemployed) %>% 
    pivot_longer(cols = unemployed:diff_diff_season_unemployed,
                 names_to = "components",
                 values_to = "values") %>% 
    PACF(lag_max = 24) %>% 
    autoplot() +
    facet_grid(vars(components))
# Plots of differenced unemployed, autocorrelation and partial autocorrelation
unemployment_train_ts_stationarity %>% 
    gg_tsdisplay(diff_unemployed, plot_type = "partial")
unemployment_train_ts_stationarity %>% 
    gg_tsdisplay(diff_season_unemployed, plot_type = "partial")
################################################################################
############################# ARIMA MODELLING ##################################
################################################################################
# Optimizing the best ARIMA model by minimizing AICc
# ARIMA_optimal <- unemployment_train_ts %>% model(ARIMA_optimal = ARIMA(unemployed, ic = "aicc", stepwise = FALSE, approximation = FALSE))
# ARIMA_optimal has Non-seasonal part pdq(5,1,0) and seasonal part PDQ(0,1,1) lag 12.
# Different ARIMA models to fit the unemployment trainingset
# Finding the global optimal ARIMA-model by minimizing AICc
#fit_arima_optimal <- unemployment_train_ts %>% 
 #   dplyr::dplyr::select(date, unemployed) %>% 
  #  model(ARIMA_optimal = ARIMA(unemployed, 
  #                              stepwise = FALSE,
   #                             approximation = FALSE))
#save(fit_arima_optimal, file = "../Data/arima_optimal.Rdata")
load("../Data/arima_optimal.Rdata")
arima_manual_fits <- unemployment_train_ts %>% 
    dplyr::dplyr::select(date, unemployed) %>% 
    model(ARIMA311011 = ARIMA(unemployed ~ pdq(3,1,1) + PDQ(0,1,1)),
          ARIMA111011 = ARIMA(unemployed ~ pdq(1,1,1) + PDQ(0,1,1)),
          ARIMA313011 = ARIMA(unemployed ~ pdq(3,1,1) + PDQ(0,1,1)),
          ARIMA510111 = ARIMA(unemployed ~ pdq(5,1,0) + PDQ(1,1,0))
    ) %>% 
    bind_cols(fit_arima_optimal)
# Accuracy of traningset and testset
accuracy_arima <- bind_rows(
    arima_manual_fits  %>% accuracy(),
    arima_manual_fits  %>% forecast(h = 24)  %>%  accuracy(unemployment_test_ts)
)  %>% 
    arrange(.type, MASE)  
fc_arima_manual_fits <- arima_manual_fits %>% 
    forecast(h = 24)   %>% 
    filter(year(date) <= 2020)
fc_arima_manual_fits  %>% 
    filter(.model %in% c("ARIMA_optimal", "ARIMA111011", "SNAIVE" ))  %>% 
    ggplot() +
    geom_line(aes(x = date, y = .mean, col = .model)) + 
    geom_line(aes(x = date, y = unemployed), col = "black", data = unemployment_test_ts %>% filter(year(date) > 2015))
arima_manual_fits  %>% 
    augment()  %>% 
    filter(.model %in% c("ARIMA311011", "ARIMA111011", "SNAIVE" ))  %>% 
    autoplot(.fitted) +
    autolayer(unemployment_train_ts, unemployed, col = "black")
arima_manual_fits  %>% accuracy(unemployment_test_ts)
#************************USING UNEMPLOYED**************************************#
### Store in Rdata file
fit_arima_optimal # Non-seasonal part (p,d,q) = (3,0,1) and Seasonal-part (P,D,Q)m = (0,1,1)12
report(fit_arima_optimal)
fit_arima_optimal %>% 
    glance() # check out the AICc
# Checking for problems with non-stationarity, acf or normal-distribution ------
fit_arima_optimal %>% 
    gg_tsresiduals() # Does not seems to be sign of correlation in resduals, and the histogram shows a normally distributed, this means that the prediction interval will be ok. 
Residuals <- augment(fit_arima_optimal)$.resid
ggtsdisplay(Residuals, 
            plot.type = "histogram", 
            lag.max = 24, 
            theme = theme_bw(),
            main = paste("Residuals of ", fit_arima_optimal$ARIMA_optimal, "model"))
fit_arima_optimal %>% 
    augment() %>% 
    features(.innov, ljung_box, lag = 24, dof = 4) # KVIFOR ER DET FORSKJELLIG SVAR ETTER ENDRING AV LAG OG DOF?????
fit_arima_optimal %>% 
    forecast(h = 24) %>% 
    autoplot(unemployment_test_ts %>% filter(year(date) >= 2000), 
             level = 95) +
    labs(title = "Forecast of Unemployment level with",
         subtitle = fit_arima_optimal$ARIMA_optimal,
         y = "Unemployment level", 
         x = "Month") +
    theme_bw() +
    theme(legend.position = "bottom") +
    guides(level = guide_legend(title = "Prediction interval %: "))
fc_arima_optimal <- fit_arima_optimal %>% 
    forecast(h = 12)
# RMSE of ARIMA-optimal; two methods -------------------------------------------
sqrt(mean((unemployment_test$unemployed - fc_arima_optimal$.mean)^2))
### Plot AIC optimal ARIMA vs Custom ARIma
unemployment_test_ts %>%  
    filter(year(date) >= 2017)  %>% 
    ggplot() +
    geom_line(aes(x= date, y = unemployed, col = "Original data")) +
    geom_line(aes(x = date, y = .mean, col = "fc_arima_optimal"), data =  fc_arima_optimal) + 
    geom_line(aes(x = date, y = .mean, col = "fc_arima311011"), data =  fc_arima311011) +
    labs(title = "Forecasting of unemployment US")
accuracy_arima  <- bind_rows(
    fit_arima_optimal %>% accuracy(),
    fc_arima_optimal %>% accuracy(unemployment_test_ts),
    arima_manual_fits  %>% accuracy(),
    fc_arima311011  %>%  accuracy(unemployment_test_ts)
) %>%
    dplyr::select(.model:RMSSE)  %>% 
    arrange(RMSSE)
accuracy_arima
"When comparing models using AICc, the most important part is that
the models have the same differecing order (I).
Even if the all the models does not pass a ljung-box test (prediction interval cannot
be interpreted), we can still forecast"
# Comparing ETS vs ARIMA -------------------------------------------------------
accuracy_models <- bind_rows(
    accuracy_ets,
    accuracy_arima) %>% 
    arrange(RMSSE) # Root mean square standardized effect
accuracy_models
save(fc_arima_optimal, fc_ets_optimal, file = "../Data/optimal_models.Rdata")
accuracy_models <- bind_rows(
    accuracy_ets,
    accuracy_arima) %>% 
    arrange(RMSSE)
save(fc_arima_optimal, fc_ets_optimal, file = "../Data/optimal_models.Rdata")
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSEE, -MPE)  %>% 
     arrange(MASE)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSSEE, -MPE)  %>% 
     arrange(MASE)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSSE, -MPE)  %>% 
     arrange(MASE)
mean_model <- bind_cols(fc_arima_optimal, fc_ets_optimal, fc_dynamic_naive ) 
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )
fc_arima_optimal
fc_arima_optimal <- fit_arima_optimal %>% 
    forecast(h = 24)
save(fc_arima_optimal, fc_ets_optimal, file = "../Data/optimal_models.Rdata")
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive ) 
mean_model
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )  %>% 
            mutate(mean_fc = RowMeans(x))
mean_model
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )  %>% 
            mutate(mean_fc = RowMeans(unemployed...3))
mean_model
colnames(mean_model)
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )  %>% 
           rowwise() %>% 
           mutate(mean_fc=mean(c(.mean...4, .mean...8, .mean...12 )))
mean_model
colnames(mean_model)
mean_model$mean_fc
tibble::view(mean_model)
comb_mean_fc <- bind_cols( fc_arima_optimal, fc_ets_optimal, fc_dynamic_naive )  %>% 
           rowwise() %>% 
           mutate(mean_fc=mean(c(.mean...4, .mean...8, .mean...12 )))
MASE(comb_mean_fc$mean_fc, unemployment_test, .period = 12)
unemployment_test
MASE(comb_mean_fc$mean_fc, unemployment_test$unemployed, .period = 12)
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date, y = unemployed[,"fcst"], color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) 
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date, y = unemployed[,"fcst"], color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test) 
unemployment_test
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test) +
    theme_bw()
comb_mean_fc
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date...2, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test) +
    theme_bw()
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date...2, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
    theme_bw()
RMSE(comb_mean_fc$mean_fc, unemployment_test$unemployed)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSSE, -MPE)  %>% 
     arrange(MASE)
comb_mean_fc %>% accuracy(unemployment_test_ts)
comb_mean_fc %>% accuracy(unemployment_test_ts)
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date...2, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
    theme_bw() +
    theme(legend.position = "bottom")
unemployment_test$unemployed
unemployment_test
comb_mean_fc
MASE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed, .period = 12)
RMSSE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed, .period = 12)
unemployment_test_ts
y
MASE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed  %>% head(24), .period = 12)
MASE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed  %>% tail(24), .period = 12)
help(accuracy)
fc_arima_optimal %>% forecat::accuracy()
fc_arima_optimal %>% forecast::accuracy()
fc_arima_optimal %>% fabletools::accuracy()
fc_arima_optimal %>% accuracy()
fc_arima_optimal %>% accuracy()
