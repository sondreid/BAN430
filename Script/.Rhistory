    gg_tsdisplay(diff_unemployed, plot_type = "partial")
unemployment_train_ts_stationarity %>% 
    gg_tsdisplay(diff_season_unemployed, plot_type = "partial")
################################################################################
############################# ARIMA MODELLING ##################################
################################################################################
# Optimizing the best ARIMA model by minimizing AICc
# ARIMA_optimal <- unemployment_train_ts %>% model(ARIMA_optimal = ARIMA(unemployed, ic = "aicc", stepwise = FALSE, approximation = FALSE))
# ARIMA_optimal has Non-seasonal part pdq(5,1,0) and seasonal part PDQ(0,1,1) lag 12.
# Different ARIMA models to fit the unemployment trainingset
# Finding the global optimal ARIMA-model by minimizing AICc
#fit_arima_optimal <- unemployment_train_ts %>% 
 #   dplyr::dplyr::select(date, unemployed) %>% 
  #  model(ARIMA_optimal = ARIMA(unemployed, 
  #                              stepwise = FALSE,
   #                             approximation = FALSE))
#save(fit_arima_optimal, file = "../Data/arima_optimal.Rdata")
load("../Data/arima_optimal.Rdata")
arima_manual_fits <- unemployment_train_ts %>% 
    dplyr::dplyr::select(date, unemployed) %>% 
    model(ARIMA311011 = ARIMA(unemployed ~ pdq(3,1,1) + PDQ(0,1,1)),
          ARIMA111011 = ARIMA(unemployed ~ pdq(1,1,1) + PDQ(0,1,1)),
          ARIMA313011 = ARIMA(unemployed ~ pdq(3,1,1) + PDQ(0,1,1)),
          ARIMA510111 = ARIMA(unemployed ~ pdq(5,1,0) + PDQ(1,1,0))
    ) %>% 
    bind_cols(fit_arima_optimal)
# Accuracy of traningset and testset
accuracy_arima <- bind_rows(
    arima_manual_fits  %>% accuracy(),
    arima_manual_fits  %>% forecast(h = 24)  %>%  accuracy(unemployment_test_ts)
)  %>% 
    arrange(.type, MASE)  
fc_arima_manual_fits <- arima_manual_fits %>% 
    forecast(h = 24)   %>% 
    filter(year(date) <= 2020)
fc_arima_manual_fits  %>% 
    filter(.model %in% c("ARIMA_optimal", "ARIMA111011", "SNAIVE" ))  %>% 
    ggplot() +
    geom_line(aes(x = date, y = .mean, col = .model)) + 
    geom_line(aes(x = date, y = unemployed), col = "black", data = unemployment_test_ts %>% filter(year(date) > 2015))
arima_manual_fits  %>% 
    augment()  %>% 
    filter(.model %in% c("ARIMA311011", "ARIMA111011", "SNAIVE" ))  %>% 
    autoplot(.fitted) +
    autolayer(unemployment_train_ts, unemployed, col = "black")
arima_manual_fits  %>% accuracy(unemployment_test_ts)
#************************USING UNEMPLOYED**************************************#
### Store in Rdata file
fit_arima_optimal # Non-seasonal part (p,d,q) = (3,0,1) and Seasonal-part (P,D,Q)m = (0,1,1)12
report(fit_arima_optimal)
fit_arima_optimal %>% 
    glance() # check out the AICc
# Checking for problems with non-stationarity, acf or normal-distribution ------
fit_arima_optimal %>% 
    gg_tsresiduals() # Does not seems to be sign of correlation in resduals, and the histogram shows a normally distributed, this means that the prediction interval will be ok. 
Residuals <- augment(fit_arima_optimal)$.resid
ggtsdisplay(Residuals, 
            plot.type = "histogram", 
            lag.max = 24, 
            theme = theme_bw(),
            main = paste("Residuals of ", fit_arima_optimal$ARIMA_optimal, "model"))
fit_arima_optimal %>% 
    augment() %>% 
    features(.innov, ljung_box, lag = 24, dof = 4) # KVIFOR ER DET FORSKJELLIG SVAR ETTER ENDRING AV LAG OG DOF?????
fit_arima_optimal %>% 
    forecast(h = 24) %>% 
    autoplot(unemployment_test_ts %>% filter(year(date) >= 2000), 
             level = 95) +
    labs(title = "Forecast of Unemployment level with",
         subtitle = fit_arima_optimal$ARIMA_optimal,
         y = "Unemployment level", 
         x = "Month") +
    theme_bw() +
    theme(legend.position = "bottom") +
    guides(level = guide_legend(title = "Prediction interval %: "))
fc_arima_optimal <- fit_arima_optimal %>% 
    forecast(h = 12)
# RMSE of ARIMA-optimal; two methods -------------------------------------------
sqrt(mean((unemployment_test$unemployed - fc_arima_optimal$.mean)^2))
### Plot AIC optimal ARIMA vs Custom ARIma
unemployment_test_ts %>%  
    filter(year(date) >= 2017)  %>% 
    ggplot() +
    geom_line(aes(x= date, y = unemployed, col = "Original data")) +
    geom_line(aes(x = date, y = .mean, col = "fc_arima_optimal"), data =  fc_arima_optimal) + 
    geom_line(aes(x = date, y = .mean, col = "fc_arima311011"), data =  fc_arima311011) +
    labs(title = "Forecasting of unemployment US")
accuracy_arima  <- bind_rows(
    fit_arima_optimal %>% accuracy(),
    fc_arima_optimal %>% accuracy(unemployment_test_ts),
    arima_manual_fits  %>% accuracy(),
    fc_arima311011  %>%  accuracy(unemployment_test_ts)
) %>%
    dplyr::select(.model:RMSSE)  %>% 
    arrange(RMSSE)
accuracy_arima
"When comparing models using AICc, the most important part is that
the models have the same differecing order (I).
Even if the all the models does not pass a ljung-box test (prediction interval cannot
be interpreted), we can still forecast"
# Comparing ETS vs ARIMA -------------------------------------------------------
accuracy_models <- bind_rows(
    accuracy_ets,
    accuracy_arima) %>% 
    arrange(RMSSE) # Root mean square standardized effect
accuracy_models
save(fc_arima_optimal, fc_ets_optimal, file = "../Data/optimal_models.Rdata")
accuracy_models <- bind_rows(
    accuracy_ets,
    accuracy_arima) %>% 
    arrange(RMSSE)
save(fc_arima_optimal, fc_ets_optimal, file = "../Data/optimal_models.Rdata")
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSEE, -MPE)  %>% 
     arrange(MASE)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSSEE, -MPE)  %>% 
     arrange(MASE)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSSE, -MPE)  %>% 
     arrange(MASE)
mean_model <- bind_cols(fc_arima_optimal, fc_ets_optimal, fc_dynamic_naive ) 
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )
fc_arima_optimal
fc_arima_optimal <- fit_arima_optimal %>% 
    forecast(h = 24)
save(fc_arima_optimal, fc_ets_optimal, file = "../Data/optimal_models.Rdata")
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive ) 
mean_model
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )  %>% 
            mutate(mean_fc = RowMeans(x))
mean_model
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )  %>% 
            mutate(mean_fc = RowMeans(unemployed...3))
mean_model
colnames(mean_model)
mean_model <- fc_arima_optimal  %>%  bind_cols( fc_ets_optimal, fc_dynamic_naive )  %>% 
           rowwise() %>% 
           mutate(mean_fc=mean(c(.mean...4, .mean...8, .mean...12 )))
mean_model
colnames(mean_model)
mean_model$mean_fc
tibble::view(mean_model)
comb_mean_fc <- bind_cols( fc_arima_optimal, fc_ets_optimal, fc_dynamic_naive )  %>% 
           rowwise() %>% 
           mutate(mean_fc=mean(c(.mean...4, .mean...8, .mean...12 )))
MASE(comb_mean_fc$mean_fc, unemployment_test, .period = 12)
unemployment_test
MASE(comb_mean_fc$mean_fc, unemployment_test$unemployed, .period = 12)
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date, y = unemployed[,"fcst"], color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) 
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date, y = unemployed[,"fcst"], color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test) 
unemployment_test
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test) +
    theme_bw()
comb_mean_fc
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date...2, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test) +
    theme_bw()
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date...2, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
    theme_bw()
RMSE(comb_mean_fc$mean_fc, unemployment_test$unemployed)
fc_arima_optimal %>% 
     bind_rows(fc_ets_optimal,fc_dynamic_naive )  %>% 
     accuracy(unemployment_test_ts)  %>% 
     dplyr::select(.model, RMSE:RMSSE, -MPE)  %>% 
     arrange(MASE)
comb_mean_fc %>% accuracy(unemployment_test_ts)
comb_mean_fc %>% accuracy(unemployment_test_ts)
comb_mean_fc  %>% 
    ggplot() +
    geom_line(aes(x = date...2, y = mean_fc, color = "Mean forecasting model: ARIMA, ETS, ARIMA NAIVE")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
    theme_bw() +
    theme(legend.position = "bottom")
unemployment_test$unemployed
unemployment_test
comb_mean_fc
MASE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed, .period = 12)
RMSSE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed, .period = 12)
unemployment_test_ts
y
MASE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed  %>% head(24), .period = 12)
MASE(comb_mean_fc$mean_fc, unemployment_test_ts$unemployed  %>% tail(24), .period = 12)
help(accuracy)
fc_arima_optimal %>% forecat::accuracy()
fc_arima_optimal %>% forecast::accuracy()
fc_arima_optimal %>% fabletools::accuracy()
fc_arima_optimal %>% accuracy()
fc_arima_optimal %>% accuracy()
setwd("G:/Dokumenter/Google drive folder/NHH/Master/BAN430/Repository/Script")
setwd("G:/Dokumenter/Google drive folder/NHH/Master/BAN430/Repository/Script")
source("data.r")
###############################################################################
################## Stationarity test: Exports and CPI #########################
###############################################################################
# Joining unemployment data with consumer price index (cpi) and export
multivariate_data <- unemployment_train_ts %>% 
    dplyr::select(date, unemployed)  %>% 
    left_join(cpi_train, by = "date")  %>% 
    left_join(export_train, by = "date") 
# CPI: Autocorrelation plots
ggtsdisplay(multivariate_data$cpi, 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "CPI")
# Export: Autocorrelation plots
ggtsdisplay(multivariate_data$export, 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Exports")
# CPI: KPSS test. Outcome: 1.26% p-value, needs differencing
multivariate_data  %>% 
  features(cpi, unitroot_kpss)
# CPI: KPSS test. Outcome: 10% p-value, no need for further differencing
multivariate_data  %>% 
  features(difference(cpi), unitroot_kpss)
# CPI: Autocorrelation plots after difference
ggtsdisplay(difference(multivariate_data$cpi), 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced CPI")
# Export: KPSS test. Outcome: 1% p-value, needs differencing
multivariate_data  %>% 
  features(export, unitroot_kpss) 
# Export: KPSS test. Outcome: 10% p-value, no need for further differencing
multivariate_data  %>% 
  features(difference(export), unitroot_kpss)
# Export: Autocorrelation plots after difference
ggtsdisplay(difference(multivariate_data$export), 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced Export")
################################################################################
############# Stationarity fix: Unemployed, Export & CPI #######################
################################################################################
multivariate_data_stationary <- multivariate_data  %>% 
    mutate(diff_diff_seasonal_unemployed = difference(difference(unemployed, lag = 12)),
           diff_export                   = difference(export),
           diff_cpi                      = difference(cpi))  %>% 
    dplyr::select(date, diff_diff_seasonal_unemployed, diff_export, diff_cpi)  %>% 
    as_tsibble()  
 multivariate_data_stationary   %<>% 
    filter(date > yearmonth("2001-01-01"))
##################################################################################
########### Multivariate forecast with stationary data: VAR ######################
##################################################################################
# VAR: optimal model by AICc and BIC
fit_multivariate_var <- multivariate_data_stationary %>% 
  model(VAR_aicc = fable::VAR(vars(diff_diff_seasonal_unemployed , diff_cpi, diff_export), ic = "aicc"),
        VAR_bic = fable::VAR(vars(diff_diff_seasonal_unemployed , diff_cpi, diff_export), ic = "bic"))
# VAR: forecasts
fc_multivariate_var <- fit_multivariate_var  %>% 
  forecast(h = 24)  %>% 
  as_tsibble(index = date)
# VAR: forecast adjusted with level
forecast_level <- fc_multivariate_var %>% 
  dplyr::select(".mean_diff_diff_seasonal_unemployed")  %>% 
  rename(diff_unemployed = ".mean_diff_diff_seasonal_unemployed")  %>% 
  group_by(.model)  %>% 
  mutate(diff_unemployed = cumsum(diff_unemployed) +  multivariate_data$unemployed %>% tail(1)) ## Add level
# AICc and BIC optimized forecast, VAR(5) and VAR(1)           
forecast_level  %>% 
  autoplot() +
  autolayer(unemployment_test_ts) +
  theme_bw() +
  theme(legend.position = "bottom") +
  labs(y = "Unemployment level",
       x = "Month",
       title = "Forecasting with VAR methods") +
  guides(colour = guide_legend(title = "Method:")) +
  scale_colour_manual(values=c("#56B4E9", "orange")) 
##################################################################################
####################### Multivariate forecast accuracy: VAR ######################
##################################################################################
VARselect(multivariate_data_stationary[,2:4], lag.max =24, type="const")[["selection"]] # Confirming AR term
#Fit VAR(1)
var1 <- vars:: VAR(ts(multivariate_data_stationary[,2:4]), p = 1, type="const")
var2 <- vars:: VAR(ts(multivariate_data_stationary[,2:4]), p = 2, type="const")
var5 <- vars:: VAR(ts(multivariate_data_stationary[,2:4]), p = 5, type="const")
var13 <- vars:: VAR(ts(multivariate_data_stationary[,2:4]), p = 13, type="const")
"Failed portmanteau test: Set of autocorrelation tests most likely ljung box test for several variables"
serial_port_test <- (serial.test(var13, lags.pt=24, type="PT.asymptotic"))$serial
data.frame("Chi-squared" = serial_port_test[1],
           "df"         = serial_port_test[2],
           "p.value"    = serial_port_test[3]) %>% kbl()
forecast(object= var2, h = 24) %>%
  autoplot() + xlab("Month")
aicc <- forecast_level %>% filter(.model == "VAR_aicc")
bic <- forecast_level %>% filter(.model == "VAR_bic")
var_aicc_resid <- c(unemployment_test$unemployed- aicc$diff_unemployed)
var_bic_resid  <- c(unemployment_test$unemployed- bic$diff_unemployed)
data.frame(Model = "Multivariate VAR model AICc optimized", 
            Type = "Test", 
            RMSE = RMSE(var_aicc_resid),
            MAE =  MAE(var_aicc_resid),
            MAPE = fabletools::MAPE(.resid = var_aicc_resid, .actual = c(unemployment_test$unemployed)),
            MASE =  MASE(.resid = var_aicc_resid, .train = c(unemployment_train_ts$unemployed), .period = 12),
            RMSSE = RMSSE(.resid = var_aicc_resid, .train = c(unemployment_train_ts$unemployed), .period = 12)) %>% 
    bind_rows( data.frame(Model = "Multivariate VAR model BIC optimized", 
            Type = "Test", 
            RMSE = RMSE(var_bic_resid),
            MAE =  MAE(var_bic_resid),
            MAPE = fabletools:: MAPE(.resid = var_bic_resid, .actual = c(unemployment_test$unemployed)),
            MASE = MASE(.resid = var_bic_resid, .train = c(unemployment_train_ts$unemployed), .period = 12),
            RMSSE = RMSSE(.resid = var_bic_resid, .train = c(unemployment_train_ts$unemployed), .period = 12)))%>% 
    kbl(caption = "Multivariate VAR models", digits = 2) %>%
    kable_classic(full_width = F, html_font = "Times new roman")
#################################################################################################
############################## Multivariate foorecast with VECM #################################
#################################################################################################
"Cointegrated stochastic trends --> VECM"
VARselect(multivariate_data[,2:4], lag.max =24, type="const")[["selection"]] # Confirming AR term
# Johansen test
### Identify cointegration between variables
unemployment_exports <- multivariate_data  %>%  dplyr::select(unemployed, export)
ca_jo_eigen <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "eigen",
               K = 13, spec = "longrun", season = 1) ## k = 5 AR terms
ca_jo <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "trace",
               K = 13, spec = "longrun", season = 1) ## k = 5 AR terms
summary(ca_jo)
summary(ca_jo_eigen)
ca_jo_eigen <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "eigen",
               K = 13, spec = "longrun", season = 1) ## k = 5 AR terms
ca_jo_eigen <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "eigen",
               K = 13, spec = "longrun") ## k = 5 AR terms
summary(ca_jo_eigen)
VARselect(unemployment_exports lag.max =24, type="const")[["selection"]] # Confirming AR term
VARselect(unemployment_exports, lag.max =24, type="const")[["selection"]] # Confirming AR term
unemployment_exports <- multivariate_data  %>%  dplyr::select(unemployed, export)
VARselect(unemployment_exports, lag.max =24, type="const")[["selection"]] # Confirming AR term
VARselect(unemployment_exports[,1:2], lag.max =24, type="const")[["selection"]] # Confirming AR term
ca_jo_eigen <- ca.jo(unemployment_exports, ecdet = "const", type = "eigen",
               K = 13, spec = "longrun") ## k = 5 AR terms
ca_jo_eigen <- ca.jo(unemployment_exports[,1:2], ecdet = "const", type = "eigen",
               K = 13, spec = "longrun") ## k = 5 AR terms
summary(ca_jo_eigen)
unemployment_exports <- multivariate_data  %>%  dplyr::select(unemployed, cpi)
VARselect(unemployment_exports[,1:2], lag.max =24, type="const")[["selection"]] # Confirming AR term
unemployment_exports[,1:2]
ca_jo_eigen <- ca.jo(unemployment_exports[,1:2], ecdet = "const", type = "eigen",
               K = 13, spec = "longrun") ## k = 5 AR terms
summary(ca_jo_eigen)
ca_jo_eigen <- ca.jo(unemployment_exports[,1:2], ecdet = "const", type = "trace",
               K = 13, spec = "longrun", season = 1)
ca_jo_eigen <- ca.jo(unemployment_exports[,1:2], ecdet = "const", type = "trace",
               K = 13, spec = "longrun") 
summary(ca_jo_eigen)
VARselect(multivariate_data[,2:4], lag.max =10, type="const")[["selection"]] # Confirming AR term
ca_jo <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "trace",
               K = 10, spec = "longrun", season = 1) ## k = 5 AR terms
summary(ca_jo)
ca_jo <- ca.jo(multivariate_data[,2:4], ecdet = "const", type = "trace",
               K = 10, spec = "longrun", season = 1) ## k = 5 AR terms
summary(ca_jo)
var_vec <- vec2var(ca_jo, r =1)
summary(var_vec)
serial.test(var_vec, lags.pt=24, type="PT.asymptotic")
fc_vecm <- predict(var_vec, n.ahead = 24)
fc_var_vec <- tsibble("date"= unemployment_test$date,
                      "unemployed" = (predict(var_vec, n.ahead = 24)[[1]]$unemployed)[,1:3])
colnames(fc_var_vec) <- c("date", "unemployed", "lower", "upper")
MASE(.resid = vecm_resids , .train = c(unemployment_train_ts$unemployed), .period = 12)
fc_var_vec  %>% 
    ggplot() +
    geom_line(aes(x = date, y = unemployed[,"fcst"], color = "VECM model")) +
    geom_line(aes(x = date, y = unemployed, color = "Observed unemployment"), data = unemployment_test_ts) +
    theme_bw() +
    geom_line(aes(x = date, y = unemployed[,"lower"], color = "Lower prediction interval", alpha = 0.5)) + 
    geom_line(aes(x = date, y = unemployed[,"upper"], color = "Upper prediction interval", alpha = 0.5)) +
    scale_colour_manual(values=c("#eb3434", "black", "#56B4E9", "#56B4E9")) 
fit_multivariate_var <- multivariate_data_stationary %>% 
  model(VAR_aicc = fable::VAR(vars(diff_diff_seasonal_unemployed , diff_cpi, diff_export) ~AR(13), ic = "aic"),
        VAR_bic = fable::VAR(vars(diff_diff_seasonal_unemployed , diff_cpi, diff_export), ic = "bic"))
# VAR: forecasts
fc_multivariate_var <- fit_multivariate_var  %>% 
  forecast(h = 24)  %>% 
  as_tsibble(index = date)
# VAR: forecast adjusted with level
forecast_level <- fc_multivariate_var %>% 
  dplyr::select(".mean_diff_diff_seasonal_unemployed")  %>% 
  rename(diff_unemployed = ".mean_diff_diff_seasonal_unemployed")  %>% 
  group_by(.model)  %>% 
  mutate(diff_unemployed = cumsum(diff_unemployed) +  multivariate_data$unemployed %>% tail(1)) ## Add level
# AICc and BIC optimized forecast, VAR(5) and VAR(1)           
forecast_level  %>% 
  autoplot() +
  autolayer(unemployment_test_ts) +
  theme_bw() +
  theme(legend.position = "bottom") +
  labs(y = "Unemployment level",
       x = "Month",
       title = "Forecasting with VAR methods") +
  guides(colour = guide_legend(title = "Method:")) +
  scale_colour_manual(values=c("#56B4E9", "orange")) 
serial.test(var_vec, lags.pt=10, type="PT.asymptotic")
Box.test(diff(goog200), lag=10, type="Ljung-Box")multivariate_data$cpi
setwd("G:/Dokumenter/Google drive folder/NHH/Master/BAN430/Repository/Script")
setwd("G:/Dokumenter/Google drive folder/NHH/Master/BAN430/Repository/Script")
source("data.r")
###############################################################################
################## Stationarity test: Exports and CPI #########################
###############################################################################
# Joining unemployment data with consumer price index (cpi) and export
multivariate_data <- unemployment_train_ts %>% 
    dplyr::select(date, unemployed)  %>% 
    left_join(cpi_train, by = "date")  %>% 
    left_join(export_train, by = "date") 
# CPI: Autocorrelation plots
ggtsdisplay(multivariate_data$cpi, 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "CPI")
# Export: Autocorrelation plots
ggtsdisplay(multivariate_data$export, 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Exports")
# CPI: KPSS test. Outcome: 1.26% p-value, needs differencing
multivariate_data  %>% 
  features(cpi, unitroot_kpss)
# CPI: KPSS test. Outcome: 10% p-value, no need for further differencing
multivariate_data  %>% 
  features(difference(cpi), unitroot_kpss)
# CPI: Autocorrelation plots after difference
ggtsdisplay(difference(multivariate_data$cpi), 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced CPI")
# Export: KPSS test. Outcome: 1% p-value, needs differencing
multivariate_data  %>% 
  features(export, unitroot_kpss) 
# Export: KPSS test. Outcome: 10% p-value, no need for further differencing
multivariate_data  %>% 
  features(difference(export), unitroot_kpss)
# Export: Autocorrelation plots after difference
ggtsdisplay(difference(multivariate_data$export), 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced Export")
Box.test(diff(multivariate_data$cpi), lag=10, type="Ljung-Box")
diff(multivariate_data$cpi)
multivariate_data$cpi
Box.test(diff(multivariate_data$export), lag=10, type="Ljung-Box")
Box.test(diff(diff(diff(multivariate_data$export))), lag=10, type="Ljung-Box")
diff(diff(diff(multivariate_data$export)))
diff(diff(diff(multivariate_data$export))) %>% autoplot()
diff(diff(diff(multivariate_data$export))) %>% plot()
acf(diff(diff(diff(multivariate_data$export))))
ggtsdisplay(multivariate_data$export, 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced Export")
multivariate_data
ggtsdisplay((multivariate_data %>% filter(year(date) < 2016))$export , 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced Export")
(multivariate_data %>% filter(year(date) < 2016))
(multivariate_data %>% filter(year(date) < 2016)) %>% tail()
ggtsdisplay(diff((multivariate_data %>% filter(year(date) < 2016))$export ), 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced Export")
ggtsdisplay(diff(diff((multivariate_data %>% filter(year(date) < 2016))$export )), 
            plot.type = "partial", 
            lag.max = 24, 
            theme = theme_bw(),
            main = "Differenced Export")
unitroot_kpss
unitroot_kpss(diff_ex <- diff(diff((multivariate_data %>% filter(year(date) < 2016))$export ))
diff_ex <- diff(diff((multivariate_data %>% filter(year(date) < 2016))$export ))
diff_ex <- diff(diff((multivariate_data %>% filter(year(date) < 2016))$export ))
unitroot_kpss(diff_ex)
diff_ex <- diff(diff((multivariate_data$export))
diff_ex <- diff(diff((multivariate_data$export)))
diff_ex <- diff(diff((multivariate_data$export)))
unitroot_kpss(diff_ex)
diff_cpi <- diff(diff((multivariate_data$cpi)))
